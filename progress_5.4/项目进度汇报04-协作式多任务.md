# RISC-V 操作系统内核设计进度汇报 —— 协作式多任务模块

## 一、本阶段目标

- 在之前上下文切换功能的基础上，扩展实现多任务的创建、管理与调度。
- 增强调度器功能，使其能够管理多个任务并按一定策略进行切换。
- 验证多任务并发执行的正确性与系统稳定性。

## 二、协作式多任务模块概述

多任务是现代操作系统的重要特性，它允许多个任务同时运行，共享处理器资源。本阶段的目标是构建一个基础的多任务系统，支持任务的创建、调度与切换，为后续更复杂的系统功能开发提供框架。

## 三、核心代码实现

### 1. 文件结构与功能说明

| 文件名           | 功能说明                                       |
| ---------------- | ---------------------------------------------- |
| `kernel.c`       | 主内核逻辑入口，初始化各子系统                 |
| `Makefile`       | 编译脚本，定义依赖与目标                       |
| `mem.S`          | 启动汇编及内存初始化                           |
| `os.h`           | 核心头文件，常量、结构体定义                   |
| `os.ld`          | 链接脚本，定义内存布局与符号                   |
| `page.c`         | 页级内存分配与释放实现                         |
| `platform.h`     | 平台相关定义，如地址常量                       |
| `printf.c`       | 内核调试打印函数                               |
| `start.S`        | 启动汇编，设定入口 `_start`                    |
| `types.h`        | 数据类型定义，如 `uint32_t` 等                 |
| `uart.c`         | 串口通信驱动，用于输出调试信息                 |
| `sched.c`        | 多任务调度与上下文切换实现                     |
| `entry.S`        | 上下文切换的汇编实现，包括寄存器保存和恢复逻辑 |
| `user.c`（新增） | 用户任务示例实现                               |

### 2. 核心逻辑

#### 1）任务结构与管理

- **任务栈与上下文**：每个任务分配独立的栈空间和上下文结构体，用于保存任务执行状态。
- **任务数组**：使用数组管理多个任务，每个任务对应一个栈和上下文。
- **任务索引管理**：维护当前任务索引和任务总数，支持任务的循环调度。

#### 2）任务创建

- **分配任务资源**：为新任务分配栈空间和上下文结构体。
- **初始化上下文**：设置任务的初始寄存器值，包括返回地址和栈指针。
- **添加到任务列表**：将新任务添加到任务数组中，更新任务总数。

#### 3）任务调度

- **循环调度策略**：采用简单的循环调度算法，按顺序切换任务。
- **上下文切换**：调用 `switch_to` 函数，保存当前任务上下文，恢复目标任务上下文。



### 3. 代码实现

在该模块中，任务切换是通过协作式调度实现的，而不是抢占式调度。任务切换主要依赖以下几个关键部分：

#### 1）任务创建 （`user.c`）

在 `os_main()` 函数中，通过调用 `task_create()` 函数创建两个任务：

```c
task_create(user_task0);
task_create(user_task1);
```

每个任务被分配独立的栈空间和上下文结构体。任务的入口函数分别是 `user_task0` 和 `user_task1`。

#### 2）任务运行逻辑 （`user.c`）

每个任务在自己的无限循环中运行：

```c
void user_task0(void)
{
	uart_puts("Task 0: Created!\n");
	while (1) {
		uart_puts("Task 0: Running...\n");
		task_delay(DELAY);
		task_yield();
	}
}

void user_task1(void)
{
	uart_puts("Task 1: Created!\n");
	while (1) {
		uart_puts("Task 1: Running...\n");
		task_delay(DELAY);
		task_yield();
	}
}
```

每个任务在运行一段时间后，会主动调用 `task_yield()` 函数让出 CPU。

#### 3）主动让出 CPU （`sched.c`）

当任务调用 `task_yield()` 时，会触发任务切换：

```c
void task_yield()
{
	schedule();
}
```

`task_yield()` 会调用 `schedule()` 函数，选择下一个任务来运行。

#### 4）任务调度 （`sched.c`）

`schedule()` 函数实现了简单的循环调度算法：

```c
void schedule()
{
	if (_top <= 0) {
		panic("Num of task should be greater than zero!");
		return;
	}

	_current = (_current + 1) % _top; // 选择下一个任务
	struct context *next = &(ctx_tasks[_current]);
	switch_to(next); // 切换到下一个任务
}
```

调度器会按顺序选择下一个任务，并调用 `switch_to()` 函数进行上下文切换。

#### 5）上下文切换 （`entry.S`）

`switch_to()` 函数是任务切换的核心，它保存当前任务的上下文，并恢复下一个任务的上下文：

```assembly
switch_to:
    csrrw   t6, mscratch, t6    # 交换 t6 和 mscratch 的值
    beqz    t6, 1f              # 如果是首次调用（mscratch 为 0），跳转到 1f

    # 保存前一个任务上下文
    reg_save t6

    # 保存特殊寄存器 t6 到上下文
    mv      t5, t6              # t5 指向当前任务上下文
    csrr    t6, mscratch        # 从 mscratch 读取值
    STORE   t6, 30*SIZE_REG(t5) # 保存 t6 到上下文

1:
    # 切换到新任务上下文
    csrw    mscratch, a0        # 更新 mscratch 为新任务上下文指针

    # 恢复新任务的通用寄存器
    mv      t6, a0
    reg_restore t6

    # 恢复程序计数器，开始执行新任务
    ret
```

#### 6）总结

任务切换的过程可以总结为以下几个步骤：

1. **任务主动让出 CPU**：当前任务调用 `task_yield()`，触发任务切换。
2. **调度器选择新任务**：`schedule()` 函数选择下一个要运行的任务。
3. **保存当前任务上下文**：`switch_to()` 函数保存当前任务的寄存器状态。
4. **恢复新任务上下文**：`switch_to()` 函数恢复新任务的寄存器状态。
5. **切换到新任务**：新任务从上次中断的地方继续执行。

这种协作式调度的优点是简单易实现，但缺点是任务必须主动让出 CPU，无法实现真正的并发。

#### 

### 4. 关键数据结构

- **任务上下文**：保存任务执行所需的所有寄存器状态。

```c
struct context {
    reg_t ra;  // 返回地址
    reg_t sp;  // 栈指针
    reg_t gp;  // 全局指针
    reg_t tp;  // 线程指针
    reg_t t0;  // 临时寄存器
    reg_t t1;
    reg_t t2;
    reg_t s0;  // 保存寄存器
    reg_t s1;
    reg_t a0;  // 函数参数
    reg_t a1;
    reg_t a2;
    reg_t a3;
    reg_t a4;
    reg_t a5;
    reg_t a6;
    reg_t a7;
    reg_t s2;
    reg_t s3;
    reg_t s4;
    reg_t s5;
    reg_t s6;
    reg_t s7;
    reg_t s8;
    reg_t s9;
    reg_t s10;
    reg_t s11;
    reg_t t3;
    reg_t t4;
    reg_t t5;
    reg_t t6;
};
```

## 四、问题与解决方案

### 问题 1：任务切换时寄存器状态混乱

**现象**：任务切换后，寄存器状态不正确，导致任务行为异常。

**解决方案**：
- 确保在 `switch_to` 函数中正确保存和恢复所有寄存器。
- 在汇编代码中严格按照上下文结构体的布局进行寄存器的保存和恢复。
- 验证上下文保存和恢复逻辑的正确性。

### 问题 2：任务调度顺序异常

**现象**：任务调度顺序与预期不符，出现任务未按顺序执行的情况。

**解决方案**：
- 检查调度器的索引更新逻辑，确保任务索引正确循环。
- 验证 `_current` 和 `_top` 变量的正确性，避免数组越界。
- 在调度器中添加调试输出，跟踪任务切换顺序。

### 问题 3：任务堆栈溢出

**现象**：任务运行一段时间后崩溃，怀疑是堆栈溢出。

**解决方案**：
- 增加任务堆栈大小，观察是否解决问题。
- 在任务函数中避免使用过大的局部变量。
- 实现堆栈边界检查机制，检测堆栈溢出。

## 五、实验验证过程与结果

### 多任务创建与调度测试

1. **创建两个任务**：`user_task0` 和 `user_task1`。
2. **观察任务输出**：通过串口输出观察任务的创建和运行情况。
3. **验证任务切换**：检查两个任务是否能够按预期顺序交替执行。
4. **稳定性测试**：让系统运行一段时间，观察是否出现崩溃或异常行为。

**预期输出示例**：

```
Task 0: Created!
Task 1: Created!
Task 0: Running...
Task 1: Running...
Task 0: Running...
Task 1: Running...
...
```

### 测试结果

- 两个任务能够成功创建并交替执行。
- 任务切换正常，输出符合预期。
- 系统在长时间运行后未出现崩溃或异常，稳定性良好。

## 六、当前成果总结

- √ 扩展了调度器功能，支持多任务的创建和管理。
- √ 实现了多任务的循环调度，任务能够按顺序切换。
- √ 验证了多任务系统的正确性和稳定性。
- √ 为后续实现更复杂的调度算法和功能提供了基础。

## 七、后续计划

| 任务方向       | 简述                                       |
| -------------- | ------------------------------------------ |
| 增加强占式调度 | 实现基于中断的抢占式任务调度               |
| 优先级调度支持 | 支持任务优先级，实现优先级调度算法         |
| 任务间通信机制 | 实现任务间通信原语，如信号量、消息队列     |
| 内存隔离机制   | 为每个任务分配独立的内存空间，防止相互干扰 |
| 用户态任务支持 | 支持用户态任务的创建和管理                 |

## 八、版本记录

- **日期**：2025.5.3  
- **修改说明**：完成多任务模块的开发与测试，实现了多任务的创建、调度和切换功能。验证了系统的稳定性和正确性。
- **负责人**：杨芊萌