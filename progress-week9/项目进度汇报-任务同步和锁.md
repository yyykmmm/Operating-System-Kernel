# RISC-V OS 内核进度报告

## 一、本阶段目标与实验概述

本阶段目标是完成操作系统内核中任务同步与锁机制的培育实验，实现一种基本的自旋锁机制用于保护共享资源，避免多任务进入同一个临界区造成冲突。实验培育基本的任务运行架构，通过 UART 输出验证同步效果。

## 二、实验验证过程与结果

设计两组实验，分别为使用锁和不使用锁的情况，观察任务 0 的关键区是否能被完整执行。

### 情况一：使用锁

添加 `#define USE_LOCK`，并在 `user_task0`中使用 `spin_lock()` 和 `spin_unlock()` 封装 UART 输出。

输出示例：

```
Task 0: Begin ...
Task 0: Running...
Task 0: Running...
Task 0: Running...
Task 0: Running...
Task 0: Running...
Task 0: End ...
```

* 分析：每次执行关键区都是完整的，未被任何任务打断，说明锁设计运行正常。

### 情况二：不使用锁

注释掉 `#define USE_LOCK`，关键区无任何锁保护。

输出示例：

```
Task 0: Begin ...
Task 0: Running...
Task 0: Running...
timer interruption!
Task 1: Running...
...
Task 0: Running...
Task 0: End ...
```

* 分析： Task 0 在执行关键区时被中断打断，Task 1 接续执行，表明关键区存在竞态。

### 总结对比

| 对比项     | 使用锁    | 不使用锁     |
| ------- | ------ | -------- |
| 任务 0 输出 | 完整，无打断 | 被中断，打断执行 |
| 任务切换时机  | 锁防拥有   | 任务交叉     |
| 关键区竞态   | 无      | 存在       |

## 三、内核架构清单

当前项目所包含文件：

```
entry.S
kernel.c
lock.c
Makefile
mem.S
os.h
os.ld
page.c
platform.h
plic.c
printf.c
riscv.h
sched.c
start.S
timer.c
trap.c
types.h
uart.c
user.c
```

## 四、核心模块与代码分析

### 1. lock.c 自旋锁实现

基于关中断实现，实现构成:

```c
int spin_lock() {
    w_mstatus(r_mstatus() & ~MSTATUS_MIE);
    return 0;
}

int spin_unlock() {
    w_mstatus(r_mstatus() | MSTATUS_MIE);
    return 0;
}
```

* 问题：方法简单粗暴，通过关 MIE 位来禁止中断，有效保护临界区，但不适用于多核环境。

### 2. user.c 任务实现

通过 `task_create` 创建 user\_task0 和 user\_task1，无结束场景循环执行，用于验证输出任务切换和锁效果。

## 五、实现问题与未来展望

* 目前自旋锁实现简单粗暴，通过关 MIE 禁止中断，实际上是一种“把手住耳机”的做法，并非真正的锁实现。
* 不适合执行耗时过长的临界区操作，否则将导致系统无法响应中断，导致进程损坏或程序卡死。
* 后续展望：

  * 实现真正的 busy-wait 自旋锁（利用 atomic 指令）
  * 展示信号量、互斥量等高级同步原语
  * 实现多核同步和静态分配支持

## 六、版本记录

| 日期        | 修改内容              | 负责人 |
| --------- | ----------------- | --- |
| 2025/6/20 | 初始化实现自旋锁          | 文玉晨 |
| 2025/6/22 | 增加任务创建和 UART 输出   | 文玉晨 |
| 2025/6/25 | 完成最终实验验证，开始写转设计文档 | 文玉晨 |
| 2025/6/26 | 完成报告、完善对比分析       | 文玉晨 |

## 附录：关键代码

### spin\_lock.c

```c
#include "os.h"

int spin_lock()
{
	w_mstatus(r_mstatus() & ~MSTATUS_MIE);
	return 0;
}

int spin_unlock()
{
	w_mstatus(r_mstatus() | MSTATUS_MIE);
	return 0;
}
```

### user.c 任务函数类

```c
#include "os.h"

#define DELAY 4000

#define USE_LOCK

void user_task0(void)
{
	uart_puts("Task 0: Created!\n");
	while (1) {
#ifdef USE_LOCK
		spin_lock();
#endif
		uart_puts("Task 0: Begin ... \n");
		for (int i = 0; i < 5; i++) {
			uart_puts("Task 0: Running... \n");
			task_delay(DELAY);
		}
		uart_puts("Task 0: End ... \n");
#ifdef USE_LOCK
		spin_unlock();
#endif
	}
}

void user_task1(void)
{
	uart_puts("Task 1: Created!\n");
	while (1) {
		uart_puts("Task 1: Begin ... \n");
		for (int i = 0; i < 5; i++) {
			uart_puts("Task 1: Running... \n");
			task_delay(DELAY);
		}
		uart_puts("Task 1: End ... \n");
	}
}

/* NOTICE: DON'T LOOP INFINITELY IN main() */
void os_main(void)
{
	task_create(user_task0);
	task_create(user_task1);
}

```
