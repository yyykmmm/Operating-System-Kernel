基于C语言和RISC-V汇编的开发计划（3人团队），针对QEMU虚拟平台的操作系统内核开发：

（备注：以下为初步计划，实际开发过程中可能结合具体需求做相应调整变化）

---

### **技术栈调整**
- **开发语言**：C（主体） + RISC-V汇编（关键路径）
- **工具链**：riscv64-unknown-elf-gcc + GNU Binutils
- **关键库**：OpenSBI（M模式固件）
- **调试工具**：riscv64-unknown-elf-gdb + QEMU监控
- **构建系统**：Makefile + CMake

---

### **详细开发计划（20周）**

#### **阶段1：基础搭建与环境准备（第1-3周）**
| **周** | **核心任务**               | **技术细节**                                                 | **交付物**                               |
| ------ | -------------------------- | ------------------------------------------------------------ | ---------------------------------------- |
| W1     | RISC-V架构速成<br>环境搭建 | - 学习RV64IMAC指令集<br>- 配置交叉编译工具链<br>- QEMU启动脚本(`-machine virt`) | 可运行QEMU的Ubuntu环境<br>工具链验证脚本 |
| W2     | 裸机启动程序               | - 汇编编写`_start`入口点<br>- 链接脚本(`kernel.ld`)<br>- OpenSBI接口调用(`sbi_call`) | 打印"Hello OS"的裸机程序                 |
| W3     | C运行时环境                | - 栈指针初始化(汇编)<br>- BSS段清零<br>- 简单C函数调用测试   | 混合C/汇编的启动框架                     |

---

#### **阶段2：核心子系统开发（第4-13周）**

**迭代1：异常处理与中断（第4-5周）**
```c
// 异常处理框架示例
struct trap_frame {
    uint64_t regs[32];
    uint64_t sepc;
    uint64_t scause;
};

__attribute__((naked)) void trap_entry(void) {
    asm("csrrw sp, sscratch, sp"); // 切换栈
    asm("SAVE_CONTEXT");            // 汇编宏保存寄存器
    asm("call trap_handler");       // 调用C处理函数
}
```

| **任务**   | **关键技术**         | **验证方法**     |
| ---------- | -------------------- | ---------------- |
| 异常向量表 | `mtvec`寄存器设置    | 触发非法指令异常 |
| 时钟中断   | CLINT配置(0x2000000) | 周期性打印计时   |
| 上下文保存 | 汇编实现寄存器保存   | GDB检查栈帧      |

**迭代2：内存管理（第6-8周）**
```c
// 页表项结构 (Sv39)
typedef struct {
    uint64_t V:1;   // Valid
    uint64_t R:1;   // Readable
    uint64_t W:1;   // Writable
    uint64_t X:1;   // Executable
    uint64_t U:1;   // User accessible
    uint64_t PPN:44;// Physical Page Number
} pte_t;
```

| **模块**     | **实现重点**         | **调试技巧**     |
| ------------ | -------------------- | ---------------- |
| 物理内存分配 | 位图分配器           | QEMU内存映射检查 |
| 内核页表     | 恒等映射(0x80000000) | `satp`寄存器写入 |
| 缺页处理     | `scause=12/13/15`    | 故意访问非法地址 |

**迭代3：进程管理（第9-11周）**
```c
// 进程控制块
typedef struct PCB {
    uint64_t sp;            // 栈指针
    pte_t *pgd;             // 页表
    enum { RUNNING, READY } state;
    struct PCB *next;
} pcb_t;

// 上下文切换汇编
__asm__("switch_to:\n"
        "sd ra, 0(a0)\n"   // 保存当前RA
        "sd sp, 8(a0)\n"   // 保存当前SP
        "ld sp, 8(a1)\n"   // 加载新SP
        "ld ra, 0(a1)\n"   // 加载新RA
        "ret");            // 跳转到新进程
```

**迭代4：设备驱动（第12-13周）**
| **设备** | **关键地址** | **实现功能**      |
| -------- | ------------ | ----------------- |
| UART     | 0x10000000   | `putchar/getchar` |
| VirtIO   | 0x10001000   | 块设备读取        |
| PLIC     | 0x0C000000   | 中断路由          |

---

#### **阶段3：高级功能实现（第14-18周）**

**文件系统开发（第14-16周）**
```c
// 简化版EXT2结构
struct ext2_superblock {
    uint32_t inodes_count;
    uint32_t blocks_count;
    uint32_t first_data_block;
    // ...
};

// 系统调用实现
ssize_t sys_read(int fd, void *buf, size_t count) {
    struct file *f = current->files[fd];
    return f->ops->read(f, buf, count);
}
```

**多任务同步（第17-18周）**
| **同步机制** | **实现方案**        | **测试用例**   |
| ------------ | ------------------- | -------------- |
| 自旋锁       | `amoswap.w`原子指令 | 多核竞争测试   |
| 信号量       | 阻塞队列+唤醒       | 生产者-消费者  |
| 管道         | 环形缓冲区          | 进程间数据传输 |

---

#### **阶段4：集成测试与优化（第19-20周）**
| **任务**   | **具体内容**                    | **质量指标**        |
| ---------- | ------------------------------- | ------------------- |
| 稳定性测试 | 内存泄漏检测<br>24小时压力测试  | 无系统崩溃          |
| 性能优化   | TLB刷新优化<br>系统调用快速路径 | 上下文切换<100周期  |
| 演示系统   | 用户Shell支持<br>文件操作演示   | 实现5个以上基础命令 |

---

### **关键路径分工（3人团队）**
| **成员** | **核心职责** | **关键技术点**                               |
| -------- | ------------ | -------------------------------------------- |
| 成员A    | 硬件抽象层   | 启动汇编/中断处理/上下文切换<br>原子操作实现 |
| 成员B    | 内存与进程   | 页表管理/缺页处理/进程调度<br>同步原语       |
| 成员C    | I/O子系统    | 设备驱动/文件系统/系统调用<br>用户接口       |

---

### **风险管理与应对**
1. **汇编-C交互问题**
   - 对策：严格定义调用约定（RV64G ABI）
   - 工具：`objdump -D`反汇编验证

2. **内存损坏调试**
   - 对策：实现`kmemcheck`内存检查器
   - 工具：QEMU watchpoint功能

3. **进度延迟**
   - 对策：优先实现最小功能集（异常+内存+单进程）
   - 机制：双周代码评审+每日站立会议

